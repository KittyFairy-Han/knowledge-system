(window.webpackJsonp=window.webpackJsonp||[]).push([[101],{493:function(a,_,v){"use strict";v.r(_);var t=v(14),s=Object(t.a)({},(function(){var a=this,_=a._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("h1",{attrs:{id:"前端工程化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前端工程化"}},[a._v("#")]),a._v(" 前端工程化")]),a._v(" "),_("p",[a._v("前端工程化就是为了让前端开发能够“自成体系”，个人认为主要应该从模块化、组件化、规范化、自动化四个方面思考。")]),a._v(" "),_("ul",[_("li",[a._v("模块化：简单来说，模块化就是将一个大文件拆分成相互依赖的小文件，再进行统一的拼装和加载。")]),a._v(" "),_("li",[a._v("组件化：从 UI 拆分下来的每个包含模板(HTML)+样式(CSS)+逻辑(JS)功能完备的结构单元，我们称之为组件。\n"),_("blockquote",[_("p",[a._v("模块化只是在文件层面上，对代码或资源的拆分；而组件化是在设计层面上，对 UI（用户界面）的拆分。")])])]),a._v(" "),_("li",[a._v("规范化：比如目录结构、文件命名、前后端分离等。都会影响到后期的维护性，甚至代码质量。")]),a._v(" "),_("li",[a._v("自动化：任何简单机械的重复劳动都应该让机器去完成。比如打包的流程")])]),a._v(" "),_("h1",{attrs:{id:"版本控制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#版本控制"}},[a._v("#")]),a._v(" 版本控制")]),a._v(" "),_("h3",{attrs:{id:"为什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么"}},[a._v("#")]),a._v(" 为什么")]),a._v(" "),_("p",[a._v("协作性")]),a._v(" "),_("h3",{attrs:{id:"运行-yarn-会如何读取配置-怎么做"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#运行-yarn-会如何读取配置-怎么做"}},[a._v("#")]),a._v(" 运行 yarn，会如何读取配置？（怎么做）")]),a._v(" "),_("ol",[_("li",[a._v("读取 package.json 文件：Yarn 首先会读取项目的 package.json 文件，获取项目的依赖信息。")]),a._v(" "),_("li",[a._v("读取 yarn.lock 文件：")])]),a._v(" "),_("ul",[_("li",[_("ul",[_("li",[a._v("如果项目中有 yarn.lock 文件，Yarn 会读取这个文件，获取依赖的具体版本信息")])])]),a._v(" "),_("li",[_("ul",[_("li",[a._v("假设 lock 中和 package.json 中的版本不一致，也会用 yarn.lock 种的")])])]),a._v(" "),_("li",[_("ul",[_("li",[a._v("如果 yarn.lock 文件中没有某个依赖的信息，Yarn 会根据 package.json 文件中的版本范围选择一个版本，并将这个版本的信息添加到 yarn.lock 文件中。")])])])]),a._v(" "),_("ol",{attrs:{start:"3"}},[_("li",[a._v("检查 node_modules 文件夹：Yarn 会检查 node_modules 文件夹，看看需要的依赖是否已经安装。")])]),a._v(" "),_("ul",[_("li",[_("ul",[_("li",[a._v("如果已经安装，版本一致，Yarn 会跳过安装步骤。")])])]),a._v(" "),_("li",[_("ul",[_("li",[a._v("如果已安装，版本冲突，更新 node_modules 中的依赖来匹配 lock 文件。")])])]),a._v(" "),_("li",[_("ul",[_("li",[a._v("如果没有安装，Yarn 会下载并安装依赖。")])])])]),a._v(" "),_("ol",{attrs:{start:"4"}},[_("li",[a._v("下载并安装依赖")]),a._v(" "),_("li",[a._v("如果想要更新版本，记得删除 lock 和 node_modules")])]),a._v(" "),_("h3",{attrs:{id:"频繁发版问题的解决策略"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#频繁发版问题的解决策略"}},[a._v("#")]),a._v(" 频繁发版问题的解决策略")]),a._v(" "),_("ul",[_("li",[a._v("项目架构设计：比如一个组件库，尽量使组件功能单一，避免一个组件包含过多的功能。这样可以减少因为修改一个功能而影响到其他功能的情况，从而减少发版的频率。")]),a._v(" "),_("li",[a._v("项目质量把控：充分自测，减少因为 bug 要发版的情况")]),a._v(" "),_("li",[a._v("版本管理规范：对于修复 bug 和小改动，只升级补丁版本号；对于向后兼容的新功能，升级次版本号；对于不向后兼容的改动，升级主版本号。这样可以让使用者知道更新的版本是否可能影响到他们的代码。")]),a._v(" "),_("li",[a._v("使用 feature flag：对于新功能的开发，可以使用 feature flag 来控制新功能的开启和关闭。这样可以在不发版的情况下，控制新功能的发布。")]),a._v(" "),_("li",[a._v("使用 monorepo：如果你的项目由多个包组成，你可以考虑使用 monorepo 管理你的项目。这样可以更好地管理你的依赖，避免因为一个包的改动而需要发布多个包。")]),a._v(" "),_("li",[a._v("日志文档：让用户知道")])]),a._v(" "),_("h2",{attrs:{id:"考点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#考点"}},[a._v("#")]),a._v(" 考点")]),a._v(" "),_("h3",{attrs:{id:"package-lock-json、yarn-lock-干嘛用的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#package-lock-json、yarn-lock-干嘛用的"}},[a._v("#")]),a._v(" package-lock.json、yarn.lock 干嘛用的")]),a._v(" "),_("p",[a._v("这两个文件都是锁定依赖项版本的机制，以确保团队的协作和构建的可重复性。")]),a._v(" "),_("h3",{attrs:{id:"什么时候不锁定版本"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么时候不锁定版本"}},[a._v("#")]),a._v(" 什么时候不锁定版本")]),a._v(" "),_("p",[a._v("当你正在开发一个库或框架时，你的库可能会被许多不同的项目使用，这些项目可能使用的是依赖的不同版本。如果你锁定了依赖的版本，那么你的库可能只能在特定版本的依赖上正常工作，这可能会限制你的库的使用范围。")]),a._v(" "),_("h3",{attrs:{id:"package-json-的-scripts-字段和直接使用-node-运行脚本的主要区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#package-json-的-scripts-字段和直接使用-node-运行脚本的主要区别"}},[a._v("#")]),a._v(" package.json 的 scripts 字段和直接使用 Node 运行脚本的主要区别")]),a._v(" "),_("p",[a._v("在于环境和便利性。")]),a._v(" "),_("ul",[_("li",[a._v("环境：一个是项目，一个是全局")]),a._v(" "),_("li",[a._v("便利性：scripts 组合命令，不需要每次输入很长（记忆也累）")])]),a._v(" "),_("h1",{attrs:{id:"cicd-持续集成与部署"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cicd-持续集成与部署"}},[a._v("#")]),a._v(" CICD （持续集成与部署）")]),a._v(" "),_("h2",{attrs:{id:"为什么-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么-2"}},[a._v("#")]),a._v(" 为什么")]),a._v(" "),_("p",[a._v("可以帮助开发团队更快速、更频繁地交付高质量的软件产品。")]),a._v(" "),_("h3",{attrs:{id:"怎么做"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#怎么做"}},[a._v("#")]),a._v(" 怎么做")]),a._v(" "),_("ul",[_("li",[a._v("前置知识：git-版本控制、webpack-打包、jest-自动化测试、docker-容器、云服务、监控和日志")]),a._v(" "),_("li",[a._v("步骤：编写代码+Jenkins 的流程+日志监控")])]),a._v(" "),_("h3",{attrs:{id:"jenkins-把构建到部署的流程做成了自动化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jenkins-把构建到部署的流程做成了自动化"}},[a._v("#")]),a._v(" Jenkins 把构建到部署的流程做成了自动化")]),a._v(" "),_("p",[a._v("Jenkins 是一个持续集成/持续部署（CI/CD）工具，它可以自动化软件的构建、测试和部署过程。")]),a._v(" "),_("ol",[_("li",[a._v("开发人员将代码推送到代码仓库。")]),a._v(" "),_("li",[a._v("Jenkins 监测到代码变更，自动触发构建过程。")])]),a._v(" "),_("ul",[_("li",[_("ul",[_("li",[a._v("使用 Docker 创建容器")])])]),a._v(" "),_("li",[_("ul",[_("li",[a._v("在容器中，使用 webpack 打包")])])]),a._v(" "),_("li",[_("ul",[_("li",[a._v("在容器中，使用 jest 自动化测试")])])])]),a._v(" "),_("ol",{attrs:{start:"3"}},[_("li",[a._v("Jenkins 将 Docker 容器部署到云服务上。云服务可以根据需要自动扩展应用，处理更多的流量。")])]),a._v(" "),_("h3",{attrs:{id:"docker-优点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#docker-优点"}},[a._v("#")]),a._v(" Docker 优点")]),a._v(" "),_("ul",[_("li",[a._v("环境一致")]),a._v(" "),_("li",[a._v("易于部署和扩展")]),a._v(" "),_("li",[a._v("隔离")]),a._v(" "),_("li",[a._v("轻量")]),a._v(" "),_("li",[a._v("版本控制和复用")]),a._v(" "),_("li",[a._v("持续集成部署")])])])}),[],!1,null,null,null);_.default=s.exports}}]);