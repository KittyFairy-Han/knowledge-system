(window.webpackJsonp=window.webpackJsonp||[]).push([[105],{496:function(e,a,t){"use strict";t.r(a);var v=t(14),l=Object(v.a)({},(function(){var e=this,a=e._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"webpack"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack"}},[e._v("#")]),e._v(" webpack")]),e._v(" "),a("h2",{attrs:{id:"为什么要打包和构建"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么要打包和构建"}},[e._v("#")]),e._v(" 为什么要打包和构建")]),e._v(" "),a("ul",[a("li",[e._v("代码转换 （loader）")]),e._v(" "),a("li",[e._v("代码优化")]),e._v(" "),a("li",[e._v("流程自动化")]),e._v(" "),a("li",[e._v("流程规范：统一的构建流程和产出标准，有利于团队协作")])]),e._v(" "),a("h2",{attrs:{id:"做了哪些代码优化和流程自动化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#做了哪些代码优化和流程自动化"}},[e._v("#")]),e._v(" 做了哪些代码优化和流程自动化")]),e._v(" "),a("ul",[a("li",[e._v("并发构建 thread-loader -> 加快构建速度 （没有 thread-loader 的时候大家都用 happypack）")]),e._v(" "),a("li",[e._v("体积减小 tree-shaking、code-splitting、压缩 -> （webpack 4 也有这两个能力，但是 webpack5 做的更好）")]),e._v(" "),a("li",[e._v("次数减少 持久化缓存（persist-caching）、模块联邦（modules-federation） ->（原来 webpack4 需要用 dllplugin+cache-loader 这些插件以达到目的）")])]),e._v(" "),a("blockquote",[a("p",[e._v("开发时，更讲究构建快。生产时，更讲究产物体积小、次数少。所以开发环境默认没有用 tree-shaking 和 压缩")])]),e._v(" "),a("h2",{attrs:{id:"webpack-4-x-webpack-5"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack-4-x-webpack-5"}},[e._v("#")]),e._v(" webpack 4.x -> webpack 5")]),e._v(" "),a("ul",[a("li",[e._v("持久化缓存：Webpack 5 引入了持久化缓存，可以在多次构建之间保留一些构建结果，从而提高重复构建的速度。")]),e._v(" "),a("li",[e._v("模块联邦（Module Federation）：这是 Webpack 5 的一项重大特性，允许多个独立的构建共享 JavaScript 模块。")]),e._v(" "),a("li",[e._v("改进了长期缓存（Long Term Caching）：Webpack 5 对文件名的 hash 算法进行了改进，只有当文件内容改变时，文件名的 hash 才会改变。")]),e._v(" "),a("li",[e._v("更好的 Web 兼容性：Webpack 5 改进了对于各种 Web 环境的兼容性，例如浏览器、Worker 环境等。")]),e._v(" "),a("li",[e._v("实验性的支持 WebAssembly：Webpack 5 实验性地支持了 WebAssembly 模块。")])]),e._v(" "),a("h2",{attrs:{id:"对比其他"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对比其他"}},[e._v("#")]),e._v(" 对比其他")]),e._v(" "),a("h3",{attrs:{id:"vite"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vite"}},[e._v("#")]),e._v(" vite")]),e._v(" "),a("ul",[a("li",[e._v("构建速度方面：本地开发热更新快，由于 Vite 是基于 ESM 和 esbuild 的，利用 ESModule 的特性，浏览器可以按需加载，不需要重新构建整个应用。又因为 esbuild 是 go 编写的，多核心并行处理所以快。而 webpack 是 js。")]),e._v(" "),a("li",[e._v("构建速度方面：本地开发冷启动快，原理和上面一样")]),e._v(" "),a("li",[e._v("构建速度方面：生产环境是基于 Rollup 的，Rollup 的 three shaking 比 webpack 好。")]),e._v(" "),a("li",[e._v("开发者体验方面：vite 预设了一些 loader 和 plugin，上手快做到了 0 配置启动。webpack 预设的很少，但更灵活，更强大，生态更完善，适合大型复杂项目。\n"),a("blockquote",[a("p",[e._v("vite 对比 webpack 就像 vue 对比 react,Vite 和 Vue 都强调开箱即用和开发者体验.而 Webpack 和 React 则更强调灵活性和可配置性.")])])]),e._v(" "),a("li",[e._v("生态方面：webpack 生态更完善，插件丰富，适合复杂高定制大型项目。")]),e._v(" "),a("li",[e._v("兼容性方面：vite 兼容性不如 webpack")])]),e._v(" "),a("h2",{attrs:{id:"对比-esbuild-和-rollup"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对比-esbuild-和-rollup"}},[e._v("#")]),e._v(" 对比 esbuild 和 rollup")]),e._v(" "),a("ul",[a("li",[e._v("webpack 的兼容性更好：各种模块格式，所有类型项目都能用它")]),e._v(" "),a("li",[e._v("webpack 的生态系统更好：插件多、文档资料多")]),e._v(" "),a("li",[e._v("esbuild：快，构建更快")]),e._v(" "),a("li",[e._v("rollup：对 es 支持更好，打包更小")])]),e._v(" "),a("h4",{attrs:{id:""}},[a("a",{staticClass:"header-anchor",attrs:{href:"#"}},[e._v("#")]),e._v(" -")]),e._v(" "),a("p",[e._v("算法不同，一个激进，一个保守")]),e._v(" "),a("p",[e._v('Webpack 和 Rollup 的 tree-shaking 算法在处理 "副作用(side effects)" 时有所不同。在 JavaScript 中，一个模块可能会有副作用，例如修改全局变量。这些副作用可能会影响到其他模块，因此不能被 tree-shaking 删除。')]),e._v(" "),a("p",[e._v('Webpack 在处理副作用时比较保守。默认情况下，它会假设所有模块都可能有副作用，除非你在 package.json 中明确指定 "sideEffects": false。这意味着，如果你没有正确配置 sideEffects 选项，webpack 的 tree-shaking 可能不会生效。')]),e._v(" "),a("p",[e._v("相比之下，Rollup 的处理方式更加激进。它会假设所有模块都没有副作用，除非你明确指定了副作用。这意味着，即使你没有正确配置副作用，Rollup 的 tree-shaking 也可能生效。")])])}),[],!1,null,null,null);a.default=l.exports}}]);