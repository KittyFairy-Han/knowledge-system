(window.webpackJsonp=window.webpackJsonp||[]).push([[117],{522:function(t,a,s){"use strict";s.r(a);var e=s(14),r=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"web3d"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#web3d"}},[t._v("#")]),t._v(" web3d")]),t._v(" "),a("h2",{attrs:{id:"three-渲染流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#three-渲染流程"}},[t._v("#")]),t._v(" three 渲染流程")]),t._v(" "),a("ol",[a("li",[t._v("创建 3d 空间，5 要素")]),t._v(" "),a("li",[t._v("requestAnimationFrame 中 renderer.render 在 canvas 上进行像素级绘制")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("canvas "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" document"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getElementById")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"app-canvas"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//舞台")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("renderer "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" App3dScene"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("createRenderer")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("canvas"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//导演")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("scene "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" App3dScene"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("createScene")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//演员")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("camera "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" App3dScene"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("createCamera")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//相机")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("lights "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//灯光")]),t._v("\n")])])]),a("blockquote",[a("p",[t._v("不涉及到 DOM 的改变，因此不会引发回流（reflow）或重绘（repaint）。")])]),t._v(" "),a("h2",{attrs:{id:"webgl-工作流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webgl-工作流"}},[t._v("#")]),t._v(" webgl 工作流")]),t._v(" "),a("p",[t._v("首先创建并配置程序，然后创建并填充缓冲区。在绘制阶段，程序会使用缓冲区中的数据来计算顶点位置和像素颜色。")]),t._v(" "),a("ul",[a("li",[t._v("创建 WebGL 上下文：首先，你需要在 HTML 的 canvas 元素上创建一个 WebGL 上下文。这个上下文提供了所有 WebGL API，你可以通过它来控制 GPU。")]),t._v(" "),a("li",[t._v("创建着色器（Shaders）：着色器是运行在 GPU 上的小程序，用于计算顶点位置和像素颜色。WebGL 需要两种着色器：顶点着色器（Vertex Shader）和片元着色器（Fragment Shader）。")]),t._v(" "),a("li",[t._v("创建程序（Program）：程序是由顶点着色器和片元着色器链接在一起的对象。你需要将着色器附加到程序，然后链接它们。")]),t._v(" "),a("li",[t._v("创建缓冲区（Buffers）：缓冲区用于存储顶点数据和索引数据。你需要创建缓冲区，然后将数据上传到 GPU。")]),t._v(" "),a("li",[t._v("绘制：最后，你需要调用 gl.drawArrays 或 gl.drawElements 来绘制几何形状。这个过程会触发着色器，计算出每个像素的颜色。")])]),t._v(" "),a("h2",{attrs:{id:"常见概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常见概念"}},[t._v("#")]),t._v(" 常见概念")]),t._v(" "),a("h3",{attrs:{id:"法向量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#法向量"}},[t._v("#")]),t._v(" 法向量")]),t._v(" "),a("p",[t._v("是垂直于平面的向量，通常用于计算光照和碰撞。")]),t._v(" "),a("h3",{attrs:{id:"射线检测"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#射线检测"}},[t._v("#")]),t._v(" 射线检测")]),t._v(" "),a("p",[t._v("二维坐标转换为三维坐标、空间中的点发射线（方向与相机的正方向相同）、最后进行线和面的交点计算")]),t._v(" "),a("h3",{attrs:{id:"优化手段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优化手段"}},[t._v("#")]),t._v(" 优化手段")]),t._v(" "),a("ul",[a("li",[t._v("Bounding volumes：Three.js 使用边界体（如边界框（BoundingBox）和边界球（BoundingSphere））来进行初步的碰撞检测。边界体是围绕物体的简单形状，用于快速判断射线是否可能与物体相交。如果射线与物体的边界体没有交点，那么就可以立即排除这个物体，无需进行更复杂的检测。")]),t._v(" "),a("li",[t._v("Octrees：Octree 是一种空间划分数据结构，可以将 3D 空间划分成八个子空间，然后递归地对每个子空间进行同样的划分。在射线检测中，可以先检测射线是否与 Octree 的节点相交，如果不相交，那么就可以排除这个节点以及它的所有子节点，从而大大减少需要检测的物体数量。")]),t._v(" "),a("li",[t._v("Backface culling：在进行射线与三角形的交点检测时，Three.js 会忽略那些背向射线的三角形（也就是说，射线是从三角形的背面射向三角形的）。这是因为在大多数情况下，我们只关心射线从前面打到物体的情况。\n"),a("blockquote",[a("p",[t._v("Three.js 只做了第一个，所以更复杂的情况可能要用物理引擎")])])]),t._v(" "),a("li",[t._v("硬件上：射线检测的优化主要依赖于图形处理器（GPU）的并行处理能力，可以购置高端 GPU，它们有硬件加速的边界体检测、硬件加速的交点计算")])]),t._v(" "),a("h3",{attrs:{id:"webgl-深度测试和模板测试"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webgl-深度测试和模板测试"}},[t._v("#")]),t._v(" webgl 深度测试和模板测试")]),t._v(" "),a("ul",[a("li",[t._v("深度测试：遮挡关系。深度测试可以通过 WebGL 的 gl.enable(gl.DEPTH_TEST) 开启。")]),t._v(" "),a("li",[t._v("模版测试：模板测试是一种用于控制像素是否被绘制的技术。在渲染过程中，每个像素都会有一个模板值，这个值可以在渲染过程中被修改。然后，可以设置一个模板函数，这个函数会根据像素的模板值决定这个像素是否被绘制。模板测试可以用于实现一些高级的渲染效果，如镜面反射、阴影卷积等。模板测试可以通过 WebGL 的 gl.enable(gl.STENCIL_TEST) 开启。")])]),t._v(" "),a("blockquote",[a("p",[t._v("这两种测试都是在片元着色器（Fragment Shader）阶段进行的，它们都可以用于控制像素是否被绘制，但是使用的方法和目的不同。")])]),t._v(" "),a("h2",{attrs:{id:"webgpu-vs-webgl"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webgpu-vs-webgl"}},[t._v("#")]),t._v(" webgpu vs webgl")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("设计理念：WebGL 是基于 OpenGL ES 的，它是一个已经存在了很长时间的、成熟的图形 API。WebGPU 则是一个全新的设计，它参考了现代的图形 API，如 Vulkan、Metal 和 Direct3D 12。")])]),t._v(" "),a("li",[a("p",[t._v("性能：WebGL 的性能受到了一些限制，因为它的设计并不完全适应现代的图形硬件。WebGPU 则是为了充分利用现代图形硬件的性能而设计的，它提供了更低级别的、更直接的硬件访问。")])]),t._v(" "),a("li",[a("p",[t._v("功能：WebGL 提供了一套相对简单的 API，它足够用于大多数的 3D 渲染需求。WebGPU 则提供了更多的功能，如计算着色器、多线程渲染和显存管理等。")])]),t._v(" "),a("li",[a("p",[t._v("安全性：WebGPU 在设计时考虑了更多的安全性问题，例如，它提供了更强大的错误检查和处理机制。")])]),t._v(" "),a("li",[a("p",[t._v("兼容性：目前，WebGL 的兼容性更好，因为它已经被广泛支持了很长时间。WebGPU 目前还在开发中，尚未被所有浏览器支持。")])])]),t._v(" "),a("h2",{attrs:{id:"面试题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面试题"}},[t._v("#")]),t._v(" 面试题")]),t._v(" "),a("h3",{attrs:{id:"requestanimation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#requestanimation"}},[t._v("#")]),t._v(" requestAnimation")]),t._v(" "),a("p",[t._v("requestAnimationFrame 不是宏任务（macrotask）也不是微任务（microtask），它是浏览器提供的一个专门用于渲染动画的 API。它的执行时机是在每一帧的开始，也就是在所有的宏任务和微任务执行完毕，下一帧开始前。")]),t._v(" "),a("h3",{attrs:{id:"canvas-和-其他有啥不同"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#canvas-和-其他有啥不同"}},[t._v("#")]),t._v(" Canvas 和 其他有啥不同")]),t._v(" "),a("p",[t._v("Canvas 是 HTML5 提供的一个元素,用来绘制图形")]),t._v(" "),a("ul",[a("li",[t._v("工作原理是基于像素的： 其他 element 是基于对象的，比如可以移动。canvas 需要重新绘制。element 有事件委托，canvas 没有。")]),t._v(" "),a("li",[t._v("游戏用 Canvas，因为它基于像素性能好："),a("br"),t._v("\n游戏通常需要频繁地更新图形和动画，这就需要大量的绘图和重绘操作。如果使用 DOM 来实现，每次更新都需要修改 DOM 元素，这会引发浏览器的重排和重绘，消耗大量的计算资源，导致性能下降。而 canvas 上重新绘制不发生 reflow 和 repaint"),a("br"),t._v("\n主要是时间上节省")])]),t._v(" "),a("h3",{attrs:{id:"为什么需要主动-gc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要主动-gc"}},[t._v("#")]),t._v(" 为什么需要主动 GC")]),t._v(" "),a("p",[t._v("这些资源在 GPU 中被创建和使用，而不是在 JavaScript 的运行环境中。因此，JavaScript 的垃圾回收器无法自动管理这些资源。")])])}),[],!1,null,null,null);a.default=r.exports}}]);