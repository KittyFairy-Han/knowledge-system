(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{476:function(e,r,t){"use strict";t.r(r);var a=t(42),s=Object(a.a)({},(function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"recoil"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#recoil"}},[e._v("#")]),e._v(" recoil")]),e._v(" "),t("p",[e._v("和 redux 完全独立的一个状态管理库，感觉用起来很香")]),e._v(" "),t("h3",{attrs:{id:"使用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用"}},[e._v("#")]),e._v(" 使用")]),e._v(" "),t("h3",{attrs:{id:"原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[e._v("#")]),e._v(" 原理")]),e._v(" "),t("h3",{attrs:{id:"与-redux家族-对比"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#与-redux家族-对比"}},[e._v("#")]),e._v(" 与 redux家族 对比")]),e._v(" "),t("p",[e._v("使用 Redux、Mobx 当然可以，并没有什么问题，主要原因是它们本身并不是 React 库，我们是借助这些库的能力来实现状态管理。像 Redux 它本身虽然提供了强大的状态管理能力，但是使用的成本非常高，你还需要编写大量冗长的代码，另外像异步处理或缓存计算也不是这些库本身的能力，甚至需要借助其他的外部库。\n并且，它们并不能访问 React 内部的调度程序，而 Recoil 在后台使用 React 本身的状态，在未来还能提供并发模式这样的能力。")]),e._v(" "),t("p",[e._v("作者：栗鼠怪\n链接：https://juejin.cn/post/7053989347564978206\n来源：稀土掘金\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。")]),e._v(" "),t("p",[e._v("上一篇 React 的状态流管理梳理了一遍，由于 redux 家族太庞大，所以这篇接着和大家一起学习 redux 中的中间件等剩下的重要成员。"),t("br"),e._v("\n在 redux-saga 之前，"),t("a",{attrs:{href:"https://codesandbox.io/s/reactxue-xi-forked-wz2rhs?file=/src/redux-extra/index.js",target:"_blank",rel:"noopener noreferrer"}},[e._v("完整示 🌰"),t("OutboundLink")],1),e._v(" 看这里（示例中用了自己写的 combineReducer 和 thunk）。"),t("br"),e._v("\n从 redux-saga 开始，"),t("a",{attrs:{href:"https://codesandbox.io/s/reactxue-xi-forked-wz2rhs?file=/src/redux-saga/index.js",target:"_blank",rel:"noopener noreferrer"}},[e._v("完整示 🌰"),t("OutboundLink")],1),e._v(" 看这里。")]),e._v(" "),t("p",[e._v("⚠️ 以下代码只写了关键部分，具体看示例")])])}),[],!1,null,null,null);r.default=s.exports}}]);