(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{414:function(t,s,a){"use strict";a.r(s);var r=a(14),e=Object(r.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"组件化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#组件化"}},[t._v("#")]),t._v(" 组件化")]),t._v(" "),s("h3",{attrs:{id:"为什么要做组件化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么要做组件化"}},[t._v("#")]),t._v(" 为什么要做组件化？")]),t._v(" "),s("p",[t._v("（组件化可以提供代码的复用率，降低维护成本）")]),t._v(" "),s("h3",{attrs:{id:"考题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#考题"}},[t._v("#")]),t._v(" 考题")]),t._v(" "),s("ul",[s("li",[t._v("说说你对组件化的理解？举个例子体现组件化")])]),t._v(" "),s("p",[t._v("如果是开发功能性组件，我是会用面型对象的模式来做开发。面向对象的核心是封装、继承、多态。封装就是将具体化为抽象，抽象成 class，封装抽象出来的属性和方法。"),s("br"),t._v("\n比如一个顶部提示组件，都是显示一个提示信息和一个关闭按钮。这个时候就可以封装成一个基础的类。"),s("br"),t._v("\n成功就是显示成功、失败可以展开显示详情、有了多种状态，这时候可以继承基础的类，三种状态又抽象为三种 class。"),s("br"),t._v("\n设计的 2 大原则是：单一职责原则和开放封闭原则。单一职责只是抽象的类尽量保持功能专一，开闭原则指设计的时候要考虑好扩展，对修改关闭，对扩展开放。")])])}),[],!1,null,null,null);s.default=e.exports}}]);