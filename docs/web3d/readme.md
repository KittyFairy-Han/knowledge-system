# web3d

## 待补充

## css 中的透视

<!-- https://www.cnblogs.com/yanggeng/p/11285856.html
眼睛、视口、物体。与 css 属性 perspective、perspective-origin 的关系如图。
以屏幕为 Z=0 的平面，从屏幕的 perspective-origin 位置为出发点，以 perspective 为长度，向屏幕的正前方做垂线， 垂线的另一端为视点所在位置。视点与屏幕四个顶点分别画射线，形成了一个透视空间，就像我们现实生活中眼睛看到的空间范围。
![关系](./static/web3d-1.png)
改变 perspective-origin，会产生物体在移动的视觉效果，其实这是因为视点与物体产生了相对运动，物体没有动，但是看起来是动的。当视点向左移动时，物体相对向右运动，视点向右移动，物体反之。垂直方向也是同理的。
改变 perspective，perspective 的值越小，离 Z 平面越近，透视效果更明显。
translateZ 代表物体离屏幕的距离，当 translateZ 越大则说明离屏幕越近，离视点越近，所以物体会逐渐变大。当 translateZ>perspective 时，说明物体在视点的背后了，这个时候物体会消失，因为已经超出了视野范围。
[体验](https://3dtransforms.desandro.com/perspective) -->

加载时长主要就取决于模型资源加载时间较长，所以对于加载优化也是针对模型资源的加载时长。
这个项目的模型资源是动态的，模型个数都是不一定的，分批加载肯定是必要的。就这个项目来说，每批加载 5 层模型（5m ～ 10m 左右），发现首次加载还是比较慢。那对于每一批数据还能做哪些优化尽量提高加载速度呢？

### 资源体积减小

纹理关联的图片资源尺寸减小，纹理贴图由 2048x2048 降低为 512x512，移动端 512 够用了。

> 有些烘焙是涉及光的，图片降为 512 后可能会有锯齿，模糊处理一下。

### 模型加载的前置资源处理

模型加载过程中有等待页面用于过度，等待页面应该尽量简洁。否则会推迟模型开始加载资源的时间起点，造成适得其反的影响。  
下面我就用艺术馆中用到的优化举个例子：

- 过度页面由视频形式变成 loading gif 图
  视频资源体积比较大会阻塞模型的加载，且自动播放视频在移动端兼容性差。本来用视频是想要提高用户体验，但实际上成了累赘。所以，最后我们把视频替换成 loading 配合进度条显示。
- 空相框纹理原来是页面初始化时候就创建，优化后移到模型之后。

总结起来就是不必要的资源后置，必要的尽量小。

### 继续探索

资源体积减小、前置资源处理都做了，正常情况下，无缓存 5s-8s 加载结束，有缓存 2s 以内加载结束，但仍然偶现浏览器请求很慢的情况。有的时候几分钟都加载不出来。  
把并行请求改成了串行，没有出现几分钟加载不出来的问题了，但是有的时候还是很慢要十几秒才能加载出来。

- 静态资源放在本地是不是快了
- 不手动处理成 basic 是不是快
- 绘儿乐资源更多，但是加载很流畅，它的资源形式不是 glft+bin+几个大图，是.json+大量的小图。所以是不是资源形式有问题。

## 面试题

### requestAnimation

requestAnimationFrame 不是宏任务（macrotask）也不是微任务（microtask），它是浏览器提供的一个专门用于渲染动画的 API。它的执行时机是在每一帧的开始，也就是在所有的宏任务和微任务执行完毕，下一帧开始前。

### three 项目基本要素

```js
this.canvas = document.getElementById("app-canvas");
this.renderer = App3dScene.createRenderer(this.canvas);
this.scene = App3dScene.createScene();
this.camera = App3dScene.createCamera();
this.lights = //
```

### Canvas 和 其他有啥不同

Canvas 是 HTML5 提供的一个元素,用来绘制图形

- 工作原理是基于像素的： 其他 element 是基于对象的，比如可以移动。canvas 需要重新绘制。element 有事件委托，canvas 没有。
- 游戏用 Canvas，因为它基于像素性能好：  
  游戏通常需要频繁地更新图形和动画，这就需要大量的绘图和重绘操作。如果使用 DOM 来实现，每次更新都需要修改 DOM 元素，这会引发浏览器的重排和重绘，消耗大量的计算资源，导致性能下降。  
  主要是时间上节省

### 常见概念

- 法向量是垂直于平面的向量，通常用于计算光照和碰撞。

### webgpu vs webgl

- 设计理念：WebGL 是基于 OpenGL ES 的，它是一个已经存在了很长时间的、成熟的图形 API。WebGPU 则是一个全新的设计，它参考了现代的图形 API，如 Vulkan、Metal 和 Direct3D 12。

- 性能：WebGL 的性能受到了一些限制，因为它的设计并不完全适应现代的图形硬件。WebGPU 则是为了充分利用现代图形硬件的性能而设计的，它提供了更低级别的、更直接的硬件访问。

- 功能：WebGL 提供了一套相对简单的 API，它足够用于大多数的 3D 渲染需求。WebGPU 则提供了更多的功能，如计算着色器、多线程渲染和显存管理等。

- 安全性：WebGPU 在设计时考虑了更多的安全性问题，例如，它提供了更强大的错误检查和处理机制。

- 兼容性：目前，WebGL 的兼容性更好，因为它已经被广泛支持了很长时间。WebGPU 目前还在开发中，尚未被所有浏览器支持。

### 射线检测

二维坐标转换为三维坐标、空间中的点发射线（方向与相机的正方向相同）、最后进行线和面的交点计算

### 优化射线检测

- Bounding volumes：Three.js 使用边界体（如边界框（BoundingBox）和边界球（BoundingSphere））来进行初步的碰撞检测。边界体是围绕物体的简单形状，用于快速判断射线是否可能与物体相交。如果射线与物体的边界体没有交点，那么就可以立即排除这个物体，无需进行更复杂的检测。
- Octrees：Octree 是一种空间划分数据结构，可以将 3D 空间划分成八个子空间，然后递归地对每个子空间进行同样的划分。在射线检测中，可以先检测射线是否与 Octree 的节点相交，如果不相交，那么就可以排除这个节点以及它的所有子节点，从而大大减少需要检测的物体数量。
- Backface culling：在进行射线与三角形的交点检测时，Three.js 会忽略那些背向射线的三角形（也就是说，射线是从三角形的背面射向三角形的）。这是因为在大多数情况下，我们只关心射线从前面打到物体的情况。
  > Three.js 只做了第一个，所以更复杂的情况可能要用物理引擎
- 硬件上：射线检测的优化主要依赖于图形处理器（GPU）的并行处理能力，可以购置高端 GPU，它们有硬件加速的边界体检测、硬件加速的交点计算

### webgl 工作流

- 创建 WebGL 上下文：首先，你需要在 HTML 的 <canvas> 元素上创建一个 WebGL 上下文。这个上下文提供了所有 WebGL API，你可以通过它来控制 GPU。
- 创建着色器（Shaders）：着色器是运行在 GPU 上的小程序，用于计算顶点位置和像素颜色。WebGL 需要两种着色器：顶点着色器（Vertex Shader）和片元着色器（Fragment Shader）。
- 创建程序（Program）：程序是由顶点着色器和片元着色器链接在一起的对象。你需要将着色器附加到程序，然后链接它们。
- 创建缓冲区（Buffers）：缓冲区用于存储顶点数据和索引数据。你需要创建缓冲区，然后将数据上传到 GPU。
- 绘制：最后，你需要调用 gl.drawArrays 或 gl.drawElements 来绘制几何形状。这个过程会触发着色器，计算出每个像素的颜色。

### webgl 深度测试和模板测试

- 深度测试：遮挡关系。深度测试可以通过 WebGL 的 gl.enable(gl.DEPTH_TEST) 开启。
- 模版测试：模板测试是一种用于控制像素是否被绘制的技术。在渲染过程中，每个像素都会有一个模板值，这个值可以在渲染过程中被修改。然后，可以设置一个模板函数，这个函数会根据像素的模板值决定这个像素是否被绘制。模板测试可以用于实现一些高级的渲染效果，如镜面反射、阴影卷积等。模板测试可以通过 WebGL 的 gl.enable(gl.STENCIL_TEST) 开启。

> 这两种测试都是在片元着色器（Fragment Shader）阶段进行的，它们都可以用于控制像素是否被绘制，但是使用的方法和目的不同。


### 为什么需要主动 GC
这些资源在GPU中被创建和使用，而不是在JavaScript的运行环境中。因此，JavaScript的垃圾回收器无法自动管理这些资源。